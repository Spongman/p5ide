{"version":3,"sources":["loop-protect.js"],"names":["DEBUG","root","factory","define","amd","exports","module","loopProtect","this","debug","re","reSingle","labelRe","comments","code","offset","recompiled","lines","split","disableLoopProtection","method","alias","ignore","pushonly","labelPostion","insertReset","lineNum","line","matchPosition","slice","forEach","lastIndex","toLowerCase","indexOf","index","originalLineNum","printLineNumber","character","dofound","findwhile","terminator","matches","match","length","labelMatch","openBrackets","openBraces","foundLoopEnd","inCommentOrString","inMultilineComment","beforeLoop","theRest","join","substr","replace","capture","i","target","trim","directlyBeforeLoop","push","substring","insert","undefined","j","closeCommentTags","closePos","openPos","counters","state","console","log","apply","arguments","timeout","protect","lineNumber","reset","now","Date","time","hit","last","msg","proxyConsole","error"],"mappings":"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","file":"loop-protect.js","sourcesContent":["/*! Loop protect | (c) 2014 JS Bin | jsbin.mit-license.org */\n/**\n * Protect against infinite loops.\n * Look for for, while and do loops, and insert a check function at the start of\n * the loop. If the check function is called many many times then it returns\n * true, preventing the loop from running again.\n */\n\nif (typeof DEBUG === 'undefined') { DEBUG = true; } //jshint ignore:line\n\n(function (root, factory) {\n\t'use strict';\n\t/*global define*/\n\tif (typeof define === 'function' && define.amd) {\n\t\tdefine(factory(root));\n\t} else if (typeof exports === 'object') {\n\t\tmodule.exports = factory(root);\n\t} else {\n\t\troot.loopProtect = factory(root);\n\t}\n})(this, function loopProtectModule(root) {\n\t/*global DEBUG*/\n\t'use strict';\n\tlet debug = null;\n\n\t// the standard loops - note that recursive is not supported\n\tlet re = /\\b(for|while|do)\\b/g;\n\tlet reSingle = /\\b(for|while|do)\\b/;\n\tlet labelRe = /\\b(?!default:)([a-z_]{1}\\w+:)/i;\n\tlet comments = /(?:\\/\\*(?:[\\s\\S]*?)\\*\\/)|(?:([\\s;])+\\/\\/(?:.*)$)/gm;\n\n\tlet loopProtect = rewriteLoops;\n\n\t// used in the loop detection\n\tloopProtect.counters = {};\n\n\t// expose debug info\n\tloopProtect.debug = function debugSwitch(state) {\n\t\tdebug = state ? function () {\n\t\t\tconsole.log.apply(console, [].slice.apply(arguments));\n\t\t} : function () { };\n\t};\n\n\tloopProtect.debug(false); // off by default\n\n\t// the method - as this could be aliased to something else\n\tloopProtect.alias = 'loopProtect.protect';\n\n\tloopProtect.timeout = 500;\n\n\tfunction inMultilineComment(lineNum, lines) {\n\t\tif (lineNum === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet j = lineNum;\n\t\tlet closeCommentTags = 1; // let's assume we're inside a comment\n\t\tlet closePos = -1;\n\t\tlet openPos = -1;\n\n\t\tdo {\n\t\t\tDEBUG && debug('looking backwards ' + lines[j]); // jshint ignore:line\n\t\t\tclosePos = lines[j].indexOf('*/');\n\t\t\topenPos = lines[j].indexOf('/*');\n\n\t\t\tif (closePos !== -1) {\n\t\t\t\tcloseCommentTags++;\n\t\t\t}\n\n\t\t\t//check for single line /* comment */ formatted comments.\n\t\t\tif (closePos === lines[j].length - 2 && openPos !== -1) {\n\t\t\t\tcloseCommentTags--;\n\t\t\t}\n\n\t\t\tif (openPos !== -1) {\n\t\t\t\tcloseCommentTags--;\n\n\t\t\t\tif (closeCommentTags === 0) {\n\t\t\t\t\tDEBUG && debug('- exit: part of a multiline comment'); // jshint ignore:line\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tj -= 1;\n\t\t} while (j >= 0);\n\n\t\treturn false;\n\t}\n\n\tfunction inCommentOrString(index, line) {\n\t\tlet character;\n\t\twhile (--index > -1) {\n\t\t\tcharacter = line.substr(index, 1);\n\t\t\tif (character === '\"' || character === '\\'' || character === '.') {\n\t\t\t\t// our loop keyword was actually either in a string or a property, so let's exit and ignore this line\n\t\t\t\tDEBUG && debug('- exit: matched inside a string or property key'); // jshint ignore:line\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (character === '/' || character === '*') {\n\t\t\t\t// looks like a comment, go back one to confirm or not\n\t\t\t\tlet prevCharacter = line.substr(index - 1, 1);\n\t\t\t\tif (prevCharacter === '/') {\n\t\t\t\t\t// we've found a comment, so let's exit and ignore this line\n\t\t\t\t\tDEBUG && debug('- exit: part of a comment'); // jshint ignore:line\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction directlyBeforeLoop(index, lineNum, lines) {\n\t\treSingle.lastIndex = 0;\n\t\tlabelRe.lastIndex = 0;\n\t\tlet beforeLoop = false;\n\n\t\tlet theRest = lines.slice(lineNum).join('\\n').substr(index).replace(labelRe, '');\n\t\ttheRest.replace(reSingle, function commentStripper(match, capture, i) {\n\t\t\tlet target = theRest.substr(0, i).replace(comments, '').trim();\n\t\t\tDEBUG && debug('- directlyBeforeLoop: ' + target); // jshint ignore:line\n\t\t\tif (target.length === 0) {\n\t\t\t\tbeforeLoop = true;\n\t\t\t}\n\t\t\t// strip comments out of the target, and if there's nothing else\n\t\t\t// it's a valid label...I hope!\n\t\t});\n\n\t\treturn beforeLoop;\n\t}\n\n  /**\n   * Look for for, while and do loops, and inserts *just* at the start of the\n   * loop, a check function.\n   */\n\tfunction rewriteLoops(code, offset) {\n\t\tlet recompiled = [];\n\t\tlet lines = code.split('\\n');\n\t\tlet disableLoopProtection = false;\n\t\tlet method = loopProtect.alias;\n\t\tlet ignore = {};\n\t\tlet pushonly = {};\n\t\tlet labelPostion = null;\n\n\t\tfunction insertReset(lineNum, line, matchPosition) {\n\t\t\t// recompile the line with the reset **just** before the actual loop\n\t\t\t// so that we insert in to the correct location (instead of possibly\n\t\t\t// outside the logic\n\t\t\t// wrap reset and loop in a block to avoid one line loop behind\n\t\t\t// `if (false)`, insert the open brace in this function, and the close\n\t\t\t// brace after loop close brace.\n\t\t\treturn line.slice(0, matchPosition) + '{;' + method + '(' + lineNum + ', true); ' + line.slice(matchPosition);\n\t\t}\n\n\t\tif (!offset) {\n\t\t\toffset = 0;\n\t\t}\n\n\t\tlines.forEach(function eachLine(line, lineNum) {\n\t\t\t// reset our regexp each time.\n\t\t\tre.lastIndex = 0;\n\t\t\tlabelRe.lastIndex = 0;\n\n\t\t\tif (disableLoopProtection) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (line.toLowerCase().indexOf('noprotect') !== -1) {\n\t\t\t\tdisableLoopProtection = true;\n\t\t\t}\n\n\t\t\tlet index = -1;\n\t\t\tlet matchPosition = -1;\n\t\t\tlet originalLineNum = lineNum;\n\t\t\t// +1 since we're humans and don't read lines numbers from zero\n\t\t\tlet printLineNumber = lineNum - offset + 1;\n\t\t\tlet character = '';\n\t\t\t// special case for `do` loops, as they're end with `while`\n\t\t\tlet dofound = false;\n\t\t\tlet findwhile = false;\n\t\t\tlet terminator = false;\n\t\t\tlet matches = line.match(re) || [];\n\t\t\tlet match = matches.length ? matches[0] : '';\n\t\t\tlet labelMatch = line.match(labelRe) || [];\n\t\t\tlet openBrackets = 0;\n\t\t\tlet openBraces = 0;\n\t\t\tlet foundLoopEnd = false;\n\n\t\t\tif (labelMatch.length) {\n\t\t\t\tDEBUG && debug('- label match'); // jshint ignore:line\n\t\t\t\tindex = line.indexOf(labelMatch[1]);\n\t\t\t\tif (!inCommentOrString(index, line)) {\n\t\t\t\t\tif (!inMultilineComment(lineNum, lines)) {\n\t\t\t\t\t\tif (directlyBeforeLoop(index, lineNum, lines)) {\n\t\t\t\t\t\t\tDEBUG && debug('- found a label: \"' + labelMatch[0] + '\"'); // jshint ignore:line\n\t\t\t\t\t\t\tlabelPostion = lineNum;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDEBUG && debug('- ignored \"label\", false positive'); // jshint ignore:line\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDEBUG && debug('- ignored label in multline comment'); // jshint ignore:line\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tDEBUG && debug('- ignored label in string or comment'); // jshint ignore:line\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ignore[lineNum]) {\n\t\t\t\tDEBUG && debug(' -exit: ignoring line ' + lineNum + ': ' + line); // jshint ignore:line\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (pushonly[lineNum]) {\n\t\t\t\tDEBUG && debug('- exit: ignoring, but adding line ' + lineNum + ': ' + line); // jshint ignore:line\n\t\t\t\trecompiled.push(line);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if there's more than one match, we just ignore this kind of loop\n\t\t\t// otherwise I'm going to be writing a full JavaScript lexer...and god\n\t\t\t// knows I've got better things to be doing.\n\t\t\tif (match && matches.length === 1 && line.indexOf('jsbin') === -1) {\n\t\t\t\tDEBUG && debug('match on ' + match + '\\n'); // jshint ignore:line\n\n\t\t\t\t// there's a special case for protecting `do` loops, we need to first\n\t\t\t\t// prtect the `do`, but then ignore the closing `while` statement, so\n\t\t\t\t// we reset the search state for this special case.\n\t\t\t\tdofound = match === 'do';\n\n\t\t\t\t// make sure this is an actual loop command by searching backwards\n\t\t\t\t// to ensure it's not a string, comment or object property\n\t\t\t\tmatchPosition = index = line.indexOf(match);\n\n\t\t\t\t// first we need to walk backwards to ensure that our match isn't part\n\t\t\t\t// of a string or part of a comment\n\t\t\t\tif (inCommentOrString(index, line)) {\n\t\t\t\t\trecompiled.push(line);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// it's quite possible we're in the middle of a multiline\n\t\t\t\t// comment, so we'll cycle up looking for an opening comment,\n\t\t\t\t// and if there's one (and not a closing `*/`), then we'll\n\t\t\t\t// ignore this line as a comment\n\t\t\t\tif (inMultilineComment(lineNum, lines)) {\n\t\t\t\t\trecompiled.push(line);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// now work our way forward to look for '{'\n\t\t\t\tindex = line.indexOf(match) + match.length;\n\n\t\t\t\tif (index === line.length) {\n\t\t\t\t\tif (index === line.length && lineNum < (lines.length - 1)) {\n\t\t\t\t\t\t// move to the next line\n\t\t\t\t\t\tDEBUG && debug('- moving to next line'); // jshint ignore:line\n\t\t\t\t\t\trecompiled.push(line);\n\t\t\t\t\t\tlineNum++;\n\t\t\t\t\t\tline = lines[lineNum];\n\t\t\t\t\t\tignore[lineNum] = true;\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\twhile (index < line.length) {\n\t\t\t\t\tcharacter = line.substr(index, 1);\n\t\t\t\t\t// DEBUG && debug(character, index); // jshint ignore:line\n\n\t\t\t\t\tif (character === '(') {\n\t\t\t\t\t\topenBrackets++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (character === ')') {\n\t\t\t\t\t\topenBrackets--;\n\n\t\t\t\t\t\tif (openBrackets === 0 && terminator === false) {\n\t\t\t\t\t\t\tterminator = index;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (character === '{') {\n\t\t\t\t\t\topenBraces++;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (character === '}') {\n\t\t\t\t\t\topenBraces--;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (openBrackets === 0 && (character === ';' || character === '{')) {\n\t\t\t\t\t\t// if we're a non-curlies loop, then convert to curlies to get our code inserted\n\t\t\t\t\t\t// add a close brace after loop to match the open brace before reset\n\t\t\t\t\t\tif (character === ';') {\n\t\t\t\t\t\t\tif (lineNum !== originalLineNum) {\n\t\t\t\t\t\t\t\tDEBUG && debug('- multiline inline loop'); // jshint ignore:line\n\t\t\t\t\t\t\t\t// affect the compiled line\n\t\t\t\t\t\t\t\trecompiled[originalLineNum] = recompiled[originalLineNum].substring(0, terminator + 1) + '{\\nif (' + method + '(' + printLineNumber + ')) break;\\n' + recompiled[originalLineNum].substring(terminator + 1);\n\t\t\t\t\t\t\t\tline += '\\n}}\\n';\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t// simpler\n\t\t\t\t\t\t\t\tDEBUG && debug('- single line inline loop'); // jshint ignore:line\n\t\t\t\t\t\t\t\tline = line.substring(0, terminator + 1) + '{\\nif (' + method + '(' + printLineNumber + ')) break;\\n' + line.substring(terminator + 1) + '\\n}}\\n';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfoundLoopEnd = true;\n\t\t\t\t\t\t} else if (character === '{') {\n\t\t\t\t\t\t\tDEBUG && debug('- multiline with braces'); // jshint ignore:line\n\t\t\t\t\t\t\tlet insert = ';\\nif (' + method + '(' + printLineNumber + ')) break;\\n';\n\t\t\t\t\t\t\tline = line.substring(0, index + 1) + insert + line.substring(index + 1);\n\n\t\t\t\t\t\t\tindex += insert.length;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// work out where to put the reset\n\t\t\t\t\t\tif (lineNum === originalLineNum && labelPostion === null) {\n\t\t\t\t\t\t\tDEBUG && debug('- simple reset insert'); // jshint ignore:line\n\t\t\t\t\t\t\tline = insertReset(printLineNumber, line, matchPosition);\n\t\t\t\t\t\t\tindex += (';' + method + '(' + lineNum + ', true); ').length;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// insert the reset above the originalLineNum OR if this loop used\n\t\t\t\t\t\t\t// a label, we have to insert the reset *above* the label\n\t\t\t\t\t\t\tif (labelPostion === null) {\n\t\t\t\t\t\t\t\tDEBUG && debug('- reset inserted above original line'); // jshint ignore:line\n\t\t\t\t\t\t\t\trecompiled[originalLineNum] = insertReset(printLineNumber, recompiled[originalLineNum], matchPosition);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tDEBUG && debug('- reset inserted above matched label on line ' + labelPostion); // jshint ignore:line\n\t\t\t\t\t\t\t\tif (recompiled[labelPostion] === undefined) {\n\t\t\t\t\t\t\t\t\tlabelPostion--;\n\t\t\t\t\t\t\t\t\tmatchPosition = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\trecompiled[labelPostion] = insertReset(printLineNumber, recompiled[labelPostion], matchPosition);\n\t\t\t\t\t\t\t\tlabelPostion = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!dofound) {\n\t\t\t\t\t\t\tif (foundLoopEnd) {\n\t\t\t\t\t\t\t\trecompiled.push(line);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tDEBUG && debug('searching for closing brace of loop for: ' + line); // jshint ignore:line\n\t\t\t\t\t\t\twhile (line !== null) {\n\t\t\t\t\t\t\t\tcharacter = line.substr(index, 1);\n\n\t\t\t\t\t\t\t\tDEBUG && debug(index, character, openBraces); // jshint ignore:line\n\n\t\t\t\t\t\t\t\tif (character === '{') {\n\t\t\t\t\t\t\t\t\topenBraces++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (character === '}') {\n\t\t\t\t\t\t\t\t\topenBraces--;\n\t\t\t\t\t\t\t\t\tif (openBraces === 0) {\n\t\t\t\t\t\t\t\t\t\tDEBUG && debug('outside of loop, add a close brace to: ' + line); // jshint ignore:line\n\t\t\t\t\t\t\t\t\t\tline = line.substring(0, index + 1) + '}' + line.substring(index + 1);\n\t\t\t\t\t\t\t\t\t\trecompiled.push(line);\n\t\t\t\t\t\t\t\t\t\tignore[lineNum] = true;\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tindex++;\n\n\t\t\t\t\t\t\t\tif (index >= line.length) {\n\t\t\t\t\t\t\t\t\trecompiled.push(line);\n\t\t\t\t\t\t\t\t\tignore[lineNum] = true;\n\t\t\t\t\t\t\t\t\tlineNum++;\n\t\t\t\t\t\t\t\t\tline = lines[lineNum];\n\t\t\t\t\t\t\t\t\tDEBUG && debug(line); // jshint ignore:line\n\t\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tDEBUG && debug('searching for closing `while` statement for: ' + line); // jshint ignore:line\n\t\t\t\t\t\t\t// cycle forward until we find the close brace, after which should\n\t\t\t\t\t\t\t// be our while statement to ignore\n\t\t\t\t\t\t\tfindwhile = false;\n\t\t\t\t\t\t\twhile (index < line.length) {\n\t\t\t\t\t\t\t\tcharacter = line.substr(index, 1);\n\n\t\t\t\t\t\t\t\tif (character === '{') {\n\t\t\t\t\t\t\t\t\topenBraces++;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (character === '}') {\n\t\t\t\t\t\t\t\t\topenBraces--;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (openBraces === 0) {\n\t\t\t\t\t\t\t\t\tfindwhile = true;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tfindwhile = false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (openBraces === 0) {\n\t\t\t\t\t\t\t\t\tDEBUG && debug('outside of closure, looking for `while` statement: ' + line); // jshint ignore:line\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (findwhile && line.indexOf('while') !== -1) {\n\t\t\t\t\t\t\t\t\tDEBUG && debug('- exit as we found `while`: ' + line); // jshint ignore:line\n\t\t\t\t\t\t\t\t\t// TODO: handle while statement in multiple lines\n\t\t\t\t\t\t\t\t\tline += '}';\n\t\t\t\t\t\t\t\t\trecompiled.push(line);\n\t\t\t\t\t\t\t\t\tignore[lineNum] = true;\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tindex++;\n\n\t\t\t\t\t\t\t\tif (index === line.length && lineNum < (lines.length - 1)) {\n\t\t\t\t\t\t\t\t\trecompiled.push(line);\n\t\t\t\t\t\t\t\t\tignore[lineNum] = true;\n\t\t\t\t\t\t\t\t\tlineNum++;\n\t\t\t\t\t\t\t\t\tline = lines[lineNum];\n\t\t\t\t\t\t\t\t\tDEBUG && debug(line); // jshint ignore:line\n\t\t\t\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tindex++;\n\n\t\t\t\t\tif (index === line.length && lineNum < (lines.length - 1)) {\n\t\t\t\t\t\t// move to the next line\n\t\t\t\t\t\tDEBUG && debug('- moving to next line'); // jshint ignore:line\n\t\t\t\t\t\trecompiled.push(line);\n\t\t\t\t\t\tlineNum++;\n\t\t\t\t\t\tline = lines[lineNum];\n\t\t\t\t\t\tignore[lineNum] = true;\n\t\t\t\t\t\tindex = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// else we're a regular line, and we shouldn't be touched\n\t\t\t\tDEBUG && debug('regular line ' + line); // jshint ignore:line\n\t\t\t\trecompiled.push(line);\n\t\t\t}\n\t\t});\n\n\t\tDEBUG && debug('---- source ----'); // jshint ignore:line\n\t\tDEBUG && debug(code); // jshint ignore:line\n\t\tDEBUG && debug('---- rewrite ---'); // jshint ignore:line\n\t\tDEBUG && debug(recompiled.join('\\n')); // jshint ignore:line\n\t\tDEBUG && debug(''); // jshint ignore:line\n\n\t\treturn disableLoopProtection ? code : recompiled.join('\\n');\n\t}\n\n  /**\n   * Injected code in to user's code to **try** to protect against infinite\n   * loops cropping up in the code, and killing the browser. Returns true\n   * when the loops has been running for more than 100ms.\n   */\n\tloopProtect.protect = function protect(lineNumber, reset) {\n\n\t\tlet line = loopProtect.counters[lineNumber];\n\t\tif (!line)\n\t\t\tline = loopProtect.counters[lineNumber] = {};\n\t\tlet now = Date.now();\n\n\t\tif (reset) {\n\t\t\tline.time = now;\n\t\t\tline.hit = 0;\n\t\t\tline.last = 0;\n\t\t}\n\n\t\tline.hit++;\n\t\tif ((now - line.time) > loopProtect.timeout) {//} && line.hit !== line.last+1) {\n\t\t\t// We've spent over 100ms on this loop... smells infinite.\n\t\t\tloopProtect.hit(lineNumber);\n\t\t\t// Returning true prevents the loop running again\n\t\t\treturn true;\n\t\t}\n\t\tline.last++;\n\t\treturn false;\n\t};\n\n\tloopProtect.hit = function hit(line) {\n\t\tlet msg = 'Exiting potential infinite loop at line ' + line + '. To disable loop protection: add \"// noprotect\" to your code';\n\t\tif (root.proxyConsole) {\n\t\t\troot.proxyConsole.error(msg);\n\t\t} else {\n\t\t\tconsole.error(msg);\n\t\t}\n\t};\n\n\tloopProtect.reset = function reset() {\n\t\t// reset the counters\n\t\tloopProtect.counters = {};\n\t};\n\n\treturn loopProtect;\n});"]}